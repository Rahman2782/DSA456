# Part A: Analyze the listed member functions of the SortedTable

## def insert(self, key, value):
       def insert(self, key, value):

                if (self.search(key)!=None):

                        return False

 

                if(len(self) == self.cap):

                        # increase the capacity if list is full

                        new_table = [None for i in range(self.cap*2)]

                        for i in range(self.cap):

                                 new_table[i]=self.the_table[i]

                        self.the_table = new_table

                        self.cap *= 2

 

 

                self.the_table[len(self)]=self.Record(key,value)

                size = len(self)

                for i in range (0,size-1):

                        for j in range(0,size-1-i):

                               if(self.the_table[j].key>self.the_table[j+1].key):

                                         tmp=self.the_table[j]

                                        self.the_table[j]=self.the_table[j+1]

                                         self.the_table[j+1]=tmp

                return True

- **Time Complexity: O(N^2) - Quadratic Growth**
- **Space Complexity: O(1) - Constant**

This function calls search and iterates through a table. If a match is not found then the function will check if the table is full. If it is full then a new table with the double the capacity of the original table is created and copies the original elements into the new table. The new record is then added to the end of the table and is sorted via a bubble sort O(N^2). 

**NOTE:** While the function is usually O(1), it temporaily becomes O(N) whenever the table needs to grow. Copying all elements over to the new table requires space equivalent to the number of records in the table.

## def modify(self, key, value):
       def modify(self, key, value):

                i = 0

                while (i < len(self) and self.the_table[i].key != key):

                        i+=1

                if(i==len(self)):

                        return False

                else:

                        self.the_table[i].value = value

                        return True

- **Time Complexity: O(N) - Linear**
- **Space Complexity: O(1) - Constant**

This function iterates through the table to find the record with a matching key, in other words, a linear search.

## def remove(self, key):
       def remove(self, key):

                i = 0

                size = len(self)

                while (i < size and self.the_table[i].key != key):

                        i+=1

                if(i==size):

                        return False

                while(i+1 < size):

                        self.the_table[i]=self.the_table[i+1]

                        i+=1

                self.the_table[i] = None

                return True

- **Time Complexity: O(N) - Linear**
- **Space Complexity: O(1) - Constant**

This function iterates through the table to find a record with a matching key and in the worst case it will iterate through all the records. If the target record is found all following elements are shifted to fill the gap in the table.

## def search(self, key):
       def search(self, key):

                i = 0

                size = len(self)

                while i < size and self.the_table[i].key != key :

                        i+=1

                if i==size:

                        return None

                else:

                        return self.the_table[i].value

- **Time Complexity: O(N) - Linear**
- **Space Complexity: O(1) - Constant**

Finds a matching key is found in the table or reacches the end of the table in the worst case

## def capacity(self):
       def capacity(self):

                return self.cap

- **Time Complexity: O(1) - Constant**
- **Space Complexity: O(1) - Constant**

Just returns the cap value and performs a single operation not dependant on anything.

## def __len__(self):
       def __len__(self):

                i =0

                count = 0

                while(i < len(self.the_table)):

                        if(self.the_table[i]!=None):

                                 count+=1

                        i+=1

                return count

- **Time Complexity: O(N) - Linear**
- **Space Complexity: O(1) - Constant**

This function iterates through the "self.the_table" table to count elements that are not "None". Table size is equal to capacity, which is as large as N
